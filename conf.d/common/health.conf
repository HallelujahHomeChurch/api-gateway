# Health check and monitoring endpoints

# Health check endpoint (lightweight)
location = /health {
    access_log off;
    limit_req zone=health_limit burst=5 nodelay;
    
    return 200 '{"status":"ok","service":"api-gateway","timestamp":"$time_iso8601"}\n';
    add_header Content-Type application/json always;
    add_header Cache-Control "no-cache, no-store, must-revalidate" always;
}

# Health check endpoint for services
location = /health/services {
    access_log off;
    default_type application/json;
    limit_req zone=health_limit burst=5 nodelay;

    content_by_lua_block {
        local cjson = require "cjson.safe"
        local http = require "resty.http"
        
        -- Load service configuration
        local health_services = require "health_services"
        local dapr_base = health_services.dapr_base
        local service_list = health_services.services

        local function check_service(name, app_id)
            local url = string.format("%s/v1.0/invoke/%s/method/health", dapr_base, app_id)
            local httpc = http.new()
            httpc:set_timeout(2000)

            local res, err = httpc:request_uri(url, {
                method = "GET",
                headers = {
                    ["Accept"] = "application/json",
                    ["Content-Type"] = "application/json",
                }
            })

            local entry = {
                service = name,
                app_id = app_id,
                checked_at = ngx.utctime(),
            }

            if not res then
                entry.status = "down"
                entry.error = err
                return entry
            end

            entry.http_status = res.status
            entry.raw_body = res.body

            if res.status >= 200 and res.status < 300 then
                entry.status = "ok"
                if res.body and #res.body > 0 then
                    local decoded = cjson.decode(res.body)
                    entry.upstream = decoded or res.body
                end
            else
                entry.status = "down"
                entry.error = string.format("upstream status %s", res.status)
            end

            return entry
        end

        local threads = {}
        for _, svc in ipairs(service_list) do
            table.insert(threads, ngx.thread.spawn(check_service, svc.name, svc.app_id))
        end

        local ok, results = ngx.thread.wait(unpack(threads))

        if not ok then
            ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
            ngx.say(cjson.encode({
                error = "Failed to wait for health check threads",
                details = results or "unknown error"
            }))
            return
        end

        ngx.status = ngx.HTTP_OK
        ngx.say(cjson.encode(results))
    }
}

# Metrics endpoint for monitoring (internal only)
location = /metrics {
    access_log off;
    
    # Only allow localhost (for internal monitoring)
    allow 127.0.0.1;
    deny all;
    
    stub_status on;
}